# 6. ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ (Sorting Algorithms) ğŸ”¢

![Python](https://img.shields.io/badge/Python-3.7+-blue.svg)
![License](https://img.shields.io/badge/License-MIT-green.svg)
![Algorithms](https://img.shields.io/badge/Algorithms-Sorting-orange.svg)

ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ ë°ì´í„°ë¥¼ íŠ¹ì • ìˆœì„œ(ì˜¤ë¦„ì°¨ìˆœ/ë‚´ë¦¼ì°¨ìˆœ)ë¡œ ë°°ì—´í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì»´í“¨í„° ê³¼í•™ì˜ í•µì‹¬ ì£¼ì œ ì¤‘ í•˜ë‚˜ë¡œ, ë‹¤ì–‘í•œ ì ‘ê·¼ ë°©ì‹ê³¼ ì„±ëŠ¥ íŠ¹ì„±ì„ ê°€ì§‘ë‹ˆë‹¤.

> ğŸ’¡ **ì´ READMEë¥¼ ë³µì‚¬í•˜ì—¬ GitHub ë ˆí¬ì§€í† ë¦¬ì— ë°”ë¡œ ì‚¬ìš©í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤!**

## ğŸ“‹ ëª©ì°¨

- [6. ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ (Sorting Algorithms) ğŸ”¢](#6-ì •ë ¬-ì•Œê³ ë¦¬ì¦˜-sorting-algorithms-)
  - [ğŸ“‹ ëª©ì°¨](#-ëª©ì°¨)
  - [ğŸ¯ ê°œìš”](#-ê°œìš”)
    - [ì •ë ¬ì˜ ì¤‘ìš”ì„±](#ì •ë ¬ì˜-ì¤‘ìš”ì„±)
  - [ğŸ“Š ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë¹„êµí‘œ](#-ì •ë ¬-ì•Œê³ ë¦¬ì¦˜-ë¹„êµí‘œ)
  - [ğŸŒ O(nÂ²) ì •ë ¬ ì•Œê³ ë¦¬ì¦˜](#-on-ì •ë ¬-ì•Œê³ ë¦¬ì¦˜)
    - [ì„ íƒ ì •ë ¬ (Selection Sort)](#ì„ íƒ-ì •ë ¬-selection-sort)
      - [ë™ì‘ ì›ë¦¬](#ë™ì‘-ì›ë¦¬)
      - [êµ¬í˜„](#êµ¬í˜„)
    - [ì‚½ì… ì •ë ¬ (Insertion Sort)](#ì‚½ì…-ì •ë ¬-insertion-sort)
      - [ë™ì‘ ì›ë¦¬](#ë™ì‘-ì›ë¦¬-1)
      - [êµ¬í˜„](#êµ¬í˜„-1)
    - [ë²„ë¸” ì •ë ¬ (Bubble Sort)](#ë²„ë¸”-ì •ë ¬-bubble-sort)
      - [ë™ì‘ ì›ë¦¬](#ë™ì‘-ì›ë¦¬-2)
      - [êµ¬í˜„](#êµ¬í˜„-2)
  - [ğŸš€ O(n log n) ì •ë ¬ ì•Œê³ ë¦¬ì¦˜](#-on-log-n-ì •ë ¬-ì•Œê³ ë¦¬ì¦˜)
    - [í€¸ ì •ë ¬ (Quick Sort)](#í€¸-ì •ë ¬-quick-sort)
      - [ë™ì‘ ì›ë¦¬](#ë™ì‘-ì›ë¦¬-3)
      - [êµ¬í˜„](#êµ¬í˜„-3)
    - [ë³‘í•© ì •ë ¬ (Merge Sort)](#ë³‘í•©-ì •ë ¬-merge-sort)
      - [ë™ì‘ ì›ë¦¬](#ë™ì‘-ì›ë¦¬-4)
      - [êµ¬í˜„](#êµ¬í˜„-4)
    - [í™ ì •ë ¬ (Heap Sort)](#í™-ì •ë ¬-heap-sort)
      - [ë™ì‘ ì›ë¦¬](#ë™ì‘-ì›ë¦¬-5)
      - [êµ¬í˜„](#êµ¬í˜„-5)
  - [âš¡ íŠ¹ìˆ˜ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜](#-íŠ¹ìˆ˜-ì •ë ¬-ì•Œê³ ë¦¬ì¦˜)
    - [ê³„ìˆ˜ ì •ë ¬ (Counting Sort)](#ê³„ìˆ˜-ì •ë ¬-counting-sort)
    - [ê¸°ìˆ˜ ì •ë ¬ (Radix Sort)](#ê¸°ìˆ˜-ì •ë ¬-radix-sort)
  - [ğŸ—‚ï¸ í•´ì‹± (Hashing)](#ï¸-í•´ì‹±-hashing)
    - [í•´ì‹œ í…Œì´ë¸” êµ¬í˜„](#í•´ì‹œ-í…Œì´ë¸”-êµ¬í˜„)

## ğŸ¯ ê°œìš”

ì •ë ¬ì€ **ë°ì´í„°ë¥¼ íŠ¹ì • ê¸°ì¤€ì— ë”°ë¼ ìˆœì„œëŒ€ë¡œ ë°°ì—´í•˜ëŠ” ê³¼ì •**ì…ë‹ˆë‹¤. íš¨ìœ¨ì ì¸ ì •ë ¬ì€ ê²€ìƒ‰, ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”, ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ í–¥ìƒì˜ í•µì‹¬ì…ë‹ˆë‹¤.

### ì •ë ¬ì˜ ì¤‘ìš”ì„±

- **ê²€ìƒ‰ íš¨ìœ¨ì„±**: ì •ë ¬ëœ ë°ì´í„°ëŠ” ì´ì§„ íƒìƒ‰ ë“±ìœ¼ë¡œ ë¹ ë¥¸ ê²€ìƒ‰ ê°€ëŠ¥
- **ë°ì´í„° ë¶„ì„**: ìµœëŒ“ê°’, ìµœì†Ÿê°’, ì¤‘ì•™ê°’ ë“±ì„ ì‰½ê²Œ ì°¾ì„ ìˆ˜ ìˆìŒ
- **ì•Œê³ ë¦¬ì¦˜ ì „ì²˜ë¦¬**: ë§ì€ ì•Œê³ ë¦¬ì¦˜ì´ ì •ë ¬ëœ ë°ì´í„°ë¥¼ ì…ë ¥ìœ¼ë¡œ ìš”êµ¬
- **ì‚¬ìš©ì ê²½í—˜**: ì •ë ¬ëœ ë°ì´í„°ëŠ” ì‚¬ìš©ìê°€ ì´í•´í•˜ê¸° ì‰¬ì›€

## ğŸ“Š ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë¹„êµí‘œ

| ì•Œê³ ë¦¬ì¦˜ | ìµœì„  | í‰ê·  | ìµœì•… | ê³µê°„ë³µì¡ë„ | ì•ˆì •ì„± | íŠ¹ì§• |
|---------|------|------|------|-----------|--------|------|
| **ì„ íƒ ì •ë ¬** | O(nÂ²) | O(nÂ²) | O(nÂ²) | O(1) | âŒ | ê°„ë‹¨, ë©”ëª¨ë¦¬ íš¨ìœ¨ì  |
| **ì‚½ì… ì •ë ¬** | O(n) | O(nÂ²) | O(nÂ²) | O(1) | âœ… | ì‘ì€ ë°ì´í„°ì…‹ì— íš¨ìœ¨ì  |
| **ë²„ë¸” ì •ë ¬** | O(n) | O(nÂ²) | O(nÂ²) | O(1) | âœ… | êµìœ¡ìš©, ì‹¤ìš©ì„± ë‚®ìŒ |
| **í€µ ì •ë ¬** | O(n log n) | O(n log n) | O(nÂ²) | O(log n) | âŒ | ë¹ ë¦„, ì‹¤ìš©ì  |
| **ë³‘í•© ì •ë ¬** | O(n log n) | O(n log n) | O(n log n) | O(n) | âœ… | ì•ˆì •ì  ì„±ëŠ¥ |
| **í™ ì •ë ¬** | O(n log n) | O(n log n) | O(n log n) | O(1) | âŒ | ë©”ëª¨ë¦¬ íš¨ìœ¨ì  |

> **ì•ˆì •ì„±(Stability)**: ë™ì¼í•œ ê°’ì„ ê°€ì§„ ì›ì†Œë“¤ì˜ ìƒëŒ€ì  ìˆœì„œê°€ ì •ë ¬ í›„ì—ë„ ìœ ì§€ë˜ëŠ” ì„±ì§ˆ

## ğŸŒ O(nÂ²) ì •ë ¬ ì•Œê³ ë¦¬ì¦˜

### ì„ íƒ ì •ë ¬ (Selection Sort)

ë§¤ë²ˆ ìµœì†Ÿê°’ì„ ì°¾ì•„ì„œ ì•ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚¤ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

#### ë™ì‘ ì›ë¦¬

```
ì´ˆê¸° ë°°ì—´: [64, 25, 12, 22, 11]

1ë‹¨ê³„: [11, 25, 12, 22, 64]  (11ì´ ìµœì†Ÿê°’)
2ë‹¨ê³„: [11, 12, 25, 22, 64]  (12ê°€ ìµœì†Ÿê°’)
3ë‹¨ê³„: [11, 12, 22, 25, 64]  (22ê°€ ìµœì†Ÿê°’)
4ë‹¨ê³„: [11, 12, 22, 25, 64]  (25ê°€ ìµœì†Ÿê°’)
```

#### êµ¬í˜„

```python
def selection_sort(arr):
    """ì„ íƒ ì •ë ¬ êµ¬í˜„
    
    Args:
        arr: ì •ë ¬í•  ë¦¬ìŠ¤íŠ¸
    
    Returns:
        ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸
    
    Time Complexity: O(nÂ²)
    Space Complexity: O(1)
    """
    n = len(arr)
    
    for i in range(n):
        # ìµœì†Ÿê°’ì˜ ì¸ë±ìŠ¤ ì°¾ê¸°
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # ìµœì†Ÿê°’ì„ í˜„ì¬ ìœ„ì¹˜ë¡œ ì´ë™
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        
        # ì¤‘ê°„ ê³¼ì • ì¶œë ¥ (ë””ë²„ê¹…ìš©)
        print(f"ë‹¨ê³„ {i+1}: {arr}")
    
    return arr

# ì‚¬ìš© ì˜ˆì œ
if __name__ == "__main__":
    data = [64, 25, 12, 22, 11]
    print("ì´ˆê¸° ë°°ì—´:", data)
    sorted_data = selection_sort(data.copy())
    print("ì •ë ¬ ì™„ë£Œ:", sorted_data)
```

### ì‚½ì… ì •ë ¬ (Insertion Sort)

ì •ë ¬ëœ ë¶€ë¶„ì— ìƒˆë¡œìš´ ì›ì†Œë¥¼ ì ì ˆí•œ ìœ„ì¹˜ì— ì‚½ì…í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

#### ë™ì‘ ì›ë¦¬

```
ì´ˆê¸° ë°°ì—´: [64, 25, 12, 22, 11]

1ë‹¨ê³„: [25, 64, 12, 22, 11]  (25ë¥¼ ì •ë ¬ëœ ë¶€ë¶„ì— ì‚½ì…)
2ë‹¨ê³„: [12, 25, 64, 22, 11]  (12ë¥¼ ì •ë ¬ëœ ë¶€ë¶„ì— ì‚½ì…)
3ë‹¨ê³„: [12, 22, 25, 64, 11]  (22ë¥¼ ì •ë ¬ëœ ë¶€ë¶„ì— ì‚½ì…)
4ë‹¨ê³„: [11, 12, 22, 25, 64]  (11ì„ ì •ë ¬ëœ ë¶€ë¶„ì— ì‚½ì…)
```

#### êµ¬í˜„

```python
def insertion_sort(arr):
    """ì‚½ì… ì •ë ¬ êµ¬í˜„
    
    Args:
        arr: ì •ë ¬í•  ë¦¬ìŠ¤íŠ¸
    
    Returns:
        ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸
    
    Time Complexity: O(nÂ²) - ìµœì„ ì˜ ê²½ìš° O(n)
    Space Complexity: O(1)
    """
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        # keyë³´ë‹¤ í° ì›ì†Œë“¤ì„ í•œ ì¹¸ì”© ë’¤ë¡œ ì´ë™
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        # keyë¥¼ ì ì ˆí•œ ìœ„ì¹˜ì— ì‚½ì…
        arr[j + 1] = key
        
        print(f"ë‹¨ê³„ {i}: {arr}")
    
    return arr

# ì´ì§„ ì‚½ì… ì •ë ¬ (Binary Insertion Sort)
def binary_insertion_sort(arr):
    """ì´ì§„ íƒìƒ‰ì„ ì´ìš©í•œ ì‚½ì… ì •ë ¬
    
    ì‚½ì… ìœ„ì¹˜ë¥¼ ì°¾ëŠ” ê³¼ì •ì„ ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ìµœì í™”
    ë¹„êµ íšŸìˆ˜ëŠ” ì¤„ì´ì§€ë§Œ ì´ë™ íšŸìˆ˜ëŠ” ë™ì¼í•˜ì—¬ ì „ì²´ ë³µì¡ë„ëŠ” O(nÂ²)
    """
    def binary_search(arr, val, start, end):
        if start == end:
            return start if arr[start] > val else start + 1
        
        if start > end:
            return start
        
        mid = (start + end) // 2
        
        if arr[mid] < val:
            return binary_search(arr, val, mid + 1, end)
        elif arr[mid] > val:
            return binary_search(arr, val, start, mid - 1)
        else:
            return mid
    
    for i in range(1, len(arr)):
        key = arr[i]
        j = binary_search(arr, key, 0, i - 1)
        
        # ì›ì†Œë“¤ì„ í•œ ì¹¸ì”© ë’¤ë¡œ ì´ë™
        arr[j + 1:i + 1] = arr[j:i]
        arr[j] = key
    
    return arr
```

### ë²„ë¸” ì •ë ¬ (Bubble Sort)

ì¸ì ‘í•œ ì›ì†Œë“¤ì„ ë¹„êµí•˜ì—¬ í° ê°’ì„ ë’¤ë¡œ ë³´ë‚´ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

#### ë™ì‘ ì›ë¦¬

```
ì´ˆê¸° ë°°ì—´: [64, 25, 12, 22, 11]

1íŒ¨ìŠ¤: [25, 12, 22, 11, 64]  (64ê°€ ëìœ¼ë¡œ)
2íŒ¨ìŠ¤: [12, 22, 11, 25, 64]  (25ê°€ ì ì ˆí•œ ìœ„ì¹˜ë¡œ)
3íŒ¨ìŠ¤: [12, 11, 22, 25, 64]  (22ê°€ ì ì ˆí•œ ìœ„ì¹˜ë¡œ)
4íŒ¨ìŠ¤: [11, 12, 22, 25, 64]  (12ê°€ ì ì ˆí•œ ìœ„ì¹˜ë¡œ)
```

#### êµ¬í˜„

```python
def bubble_sort(arr):
    """ë²„ë¸” ì •ë ¬ êµ¬í˜„
    
    Args:
        arr: ì •ë ¬í•  ë¦¬ìŠ¤íŠ¸
    
    Returns:
        ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸
    
    Time Complexity: O(nÂ²) - ìµœì„ ì˜ ê²½ìš° O(n)
    Space Complexity: O(1)
    """
    n = len(arr)
    
    for i in range(n):
        swapped = False
        
        # ë§ˆì§€ë§‰ iê°œ ì›ì†ŒëŠ” ì´ë¯¸ ì •ë ¬ë¨
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        print(f"íŒ¨ìŠ¤ {i+1}: {arr}")
        
        # êµí™˜ì´ ì—†ì—ˆë‹¤ë©´ ì •ë ¬ ì™„ë£Œ
        if not swapped:
            break
    
    return arr

# ìµœì í™”ëœ ë²„ë¸” ì •ë ¬
def optimized_bubble_sort(arr):
    """ìµœì í™”ëœ ë²„ë¸” ì •ë ¬
    
    - ì¡°ê¸° ì¢…ë£Œ: êµí™˜ì´ ì—†ìœ¼ë©´ ì •ë ¬ ì™„ë£Œë¡œ íŒë‹¨
    - ê²½ê³„ ìµœì í™”: ë§ˆì§€ë§‰ êµí™˜ ìœ„ì¹˜ë¥¼ ê¸°ì–µí•˜ì—¬ ë‹¤ìŒ íŒ¨ìŠ¤ì˜ ë²”ìœ„ ì¶•ì†Œ
    """
    n = len(arr)
    
    while n > 1:
        new_n = 0
        for i in range(1, n):
            if arr[i-1] > arr[i]:
                arr[i-1], arr[i] = arr[i], arr[i-1]
                new_n = i
        n = new_n
    
    return arr
```

## ğŸš€ O(n log n) ì •ë ¬ ì•Œê³ ë¦¬ì¦˜

### í€¸ ì •ë ¬ (Quick Sort)

í”¼ë²—ì„ ê¸°ì¤€ìœ¼ë¡œ ë¶„í•  ì •ë³µí•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

#### ë™ì‘ ì›ë¦¬

```
ì´ˆê¸° ë°°ì—´: [64, 25, 12, 22, 11]
í”¼ë²—: 64

1. ë¶„í• : [25, 12, 22, 11] + [64] + []
2. ì¬ê·€ì ìœ¼ë¡œ ì™¼ìª½ ë¶€ë¶„ ì •ë ¬: [11, 12, 22, 25]
3. ê²°í•©: [11, 12, 22, 25, 64]
```

#### êµ¬í˜„

```python
def quick_sort(arr, low=0, high=None):
    """í€µ ì •ë ¬ êµ¬í˜„
    
    Args:
        arr: ì •ë ¬í•  ë¦¬ìŠ¤íŠ¸
        low: ì •ë ¬ ì‹œì‘ ì¸ë±ìŠ¤
        high: ì •ë ¬ ë ì¸ë±ìŠ¤
    
    Returns:
        ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸
    
    Time Complexity: í‰ê·  O(n log n), ìµœì•… O(nÂ²)
    Space Complexity: O(log n)
    """
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        # ë¶„í• 
        pivot_index = partition(arr, low, high)
        
        # í”¼ë²— ê¸°ì¤€ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ì¬ê·€ ì •ë ¬
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)
    
    return arr

def partition(arr, low, high):
    """í”¼ë²—ì„ ê¸°ì¤€ìœ¼ë¡œ ë°°ì—´ ë¶„í• 
    
    Lomuto ë¶„í•  ë°©ì‹ ì‚¬ìš©
    """
    pivot = arr[high]  # ë§ˆì§€ë§‰ ì›ì†Œë¥¼ í”¼ë²—ìœ¼ë¡œ ì„ íƒ
    i = low - 1  # ì‘ì€ ì›ì†Œë“¤ì˜ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    # í”¼ë²—ì„ ì ì ˆí•œ ìœ„ì¹˜ì— ë°°ì¹˜
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# Hoare ë¶„í•  ë°©ì‹
def hoare_partition(arr, low, high):
    """Hoare ë¶„í•  ë°©ì‹
    
    ì–‘ìª½ ëì—ì„œ ì‹œì‘í•˜ì—¬ ì¤‘ì•™ìœ¼ë¡œ ì´ë™í•˜ë©° ë¶„í• 
    ì¼ë°˜ì ìœ¼ë¡œ Lomutoë³´ë‹¤ ì•½ê°„ ë” íš¨ìœ¨ì 
    """
    pivot = arr[low]
    i = low - 1
    j = high + 1
    
    while True:
        i += 1
        while arr[i] < pivot:
            i += 1
        
        j -= 1
        while arr[j] > pivot:
            j -= 1
        
        if i >= j:
            return j
        
        arr[i], arr[j] = arr[j], arr[i]

# ëœë¤ í”¼ë²— í€µ ì •ë ¬
import random

def randomized_quick_sort(arr, low=0, high=None):
    """ëœë¤ í”¼ë²— í€µ ì •ë ¬
    
    í”¼ë²—ì„ ëœë¤í•˜ê²Œ ì„ íƒí•˜ì—¬ ìµœì•… ì¼€ì´ìŠ¤ í™•ë¥ ì„ ì¤„ì„
    """
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        # ëœë¤ í”¼ë²— ì„ íƒ
        random_index = random.randint(low, high)
        arr[random_index], arr[high] = arr[high], arr[random_index]
        
        pivot_index = partition(arr, low, high)
        randomized_quick_sort(arr, low, pivot_index - 1)
        randomized_quick_sort(arr, pivot_index + 1, high)
    
    return arr
```

### ë³‘í•© ì •ë ¬ (Merge Sort)

ë¶„í•  ì •ë³µìœ¼ë¡œ ì •ë ¬ í›„ ë³‘í•©í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

#### ë™ì‘ ì›ë¦¬

```
ì´ˆê¸° ë°°ì—´: [64, 25, 12, 22, 11]

1. ë¶„í• : [64, 25] [12, 22, 11]
2. ì¬ê·€ ë¶„í• : [64] [25] [12] [22, 11]
3. ì¬ê·€ ë¶„í• : [64] [25] [12] [22] [11]
4. ë³‘í•©: [25, 64] [12] [11, 22]
5. ë³‘í•©: [25, 64] [11, 12, 22]
6. ë³‘í•©: [11, 12, 22, 25, 64]
```

#### êµ¬í˜„

```python
def merge_sort(arr):
    """ë³‘í•© ì •ë ¬ êµ¬í˜„
    
    Args:
        arr: ì •ë ¬í•  ë¦¬ìŠ¤íŠ¸
    
    Returns:
        ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸
    
    Time Complexity: O(n log n)
    Space Complexity: O(n)
    """
    if len(arr) <= 1:
        return arr
    
    # ë¶„í• 
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # ë³‘í•©
    return merge(left, right)

def merge(left, right):
    """ë‘ ì •ë ¬ëœ ë°°ì—´ì„ ë³‘í•©
    
    Args:
        left: ì™¼ìª½ ì •ë ¬ëœ ë°°ì—´
        right: ì˜¤ë¥¸ìª½ ì •ë ¬ëœ ë°°ì—´
    
    Returns:
        ë³‘í•©ëœ ì •ë ¬ ë°°ì—´
    """
    result = []
    i = j = 0
    
    # ë‘ ë°°ì—´ì„ ë¹„êµí•˜ë©° ë³‘í•©
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # ë‚¨ì€ ì›ì†Œë“¤ ì¶”ê°€
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# In-place ë³‘í•© ì •ë ¬ (ë©”ëª¨ë¦¬ ìµœì í™”)
def in_place_merge_sort(arr, left=0, right=None):
    """In-place ë³‘í•© ì •ë ¬
    
    ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì¸ ë²„ì „ì´ì§€ë§Œ êµ¬í˜„ì´ ë³µì¡í•¨
    """
    if right is None:
        right = len(arr) - 1
    
    if left < right:
        mid = (left + right) // 2
        in_place_merge_sort(arr, left, mid)
        in_place_merge_sort(arr, mid + 1, right)
        in_place_merge(arr, left, mid, right)
    
    return arr

def in_place_merge(arr, left, mid, right):
    """In-place ë³‘í•© í•¨ìˆ˜"""
    # êµ¬í˜„ì´ ë³µì¡í•˜ì—¬ ì¼ë°˜ì ìœ¼ë¡œëŠ” ì¶”ê°€ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì„ ì„ í˜¸
    start2 = mid + 1
    
    if arr[mid] <= arr[start2]:
        return
    
    while left <= mid and start2 <= right:
        if arr[left] <= arr[start2]:
            left += 1
        else:
            value = arr[start2]
            index = start2
            
            while index != left:
                arr[index] = arr[index - 1]
                index -= 1
            
            arr[left] = value
            left += 1
            mid += 1
            start2 += 1
```

### í™ ì •ë ¬ (Heap Sort)

í™ ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•œ ì •ë ¬ì…ë‹ˆë‹¤.

#### ë™ì‘ ì›ë¦¬

```
ì´ˆê¸° ë°°ì—´: [64, 25, 12, 22, 11]

1. ìµœëŒ€ í™ êµ¬ì„±: [64, 25, 12, 22, 11]
2. ë£¨íŠ¸(ìµœëŒ“ê°’)ë¥¼ ëìœ¼ë¡œ: [11, 25, 12, 22, 64]
3. í™ ì¬êµ¬ì„±: [25, 22, 12, 11, 64]
4. ë°˜ë³µ: [11, 12, 22, 25, 64]
```

#### êµ¬í˜„

```python
def heap_sort(arr):
    """í™ ì •ë ¬ êµ¬í˜„
    
    Args:
        arr: ì •ë ¬í•  ë¦¬ìŠ¤íŠ¸
    
    Returns:
        ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸
    
    Time Complexity: O(n log n)
    Space Complexity: O(1)
    """
    n = len(arr)
    
    # ìµœëŒ€ í™ êµ¬ì„± (bottom-up)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # í™ì—ì„œ ì›ì†Œë¥¼ í•˜ë‚˜ì”© ì¶”ì¶œ
    for i in range(n - 1, 0, -1):
        # ë£¨íŠ¸(ìµœëŒ“ê°’)ë¥¼ í˜„ì¬ ë§ˆì§€ë§‰ê³¼ êµí™˜
        arr[0], arr[i] = arr[i], arr[0]
        
        # ê°ì†Œëœ í™ì—ì„œ ë£¨íŠ¸ë¥¼ í™ ì†ì„±ì— ë§ê²Œ ì¡°ì •
        heapify(arr, i, 0)
    
    return arr

def heapify(arr, heap_size, root_index):
    """í™ ì†ì„± ìœ ì§€ í•¨ìˆ˜
    
    Args:
        arr: ë°°ì—´
        heap_size: í™ í¬ê¸°
        root_index: ë£¨íŠ¸ ì¸ë±ìŠ¤
    """
    largest = root_index  # ê°€ì¥ í° ê°’ì„ ë£¨íŠ¸ë¡œ ì´ˆê¸°í™”
    left = 2 * root_index + 1  # ì™¼ìª½ ìì‹
    right = 2 * root_index + 2  # ì˜¤ë¥¸ìª½ ìì‹
    
    # ì™¼ìª½ ìì‹ì´ ë£¨íŠ¸ë³´ë‹¤ í¬ë©´
    if left < heap_size and arr[left] > arr[largest]:
        largest = left
    
    # ì˜¤ë¥¸ìª½ ìì‹ì´ í˜„ì¬ ê°€ì¥ í° ê°’ë³´ë‹¤ í¬ë©´
    if right < heap_size and arr[right] > arr[largest]:
        largest = right
    
    # ê°€ì¥ í° ê°’ì´ ë£¨íŠ¸ê°€ ì•„ë‹ˆë©´
    if largest != root_index:
        arr[root_index], arr[largest] = arr[largest], arr[root_index]
        
        # ì¬ê·€ì ìœ¼ë¡œ í™ ì†ì„± ìœ ì§€
        heapify(arr, heap_size, largest)

# í™ í´ë˜ìŠ¤ë¥¼ ì´ìš©í•œ êµ¬í˜„
class MaxHeap:
    """ìµœëŒ€ í™ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.heap = []
    
    def parent(self, i):
        return (i - 1) // 2
    
    def left_child(self, i):
        return 2 * i + 1
    
    def right_child(self, i):
        return 2 * i + 2
    
    def insert(self, value):
        """í™ì— ê°’ ì‚½ì…"""
        self.heap.append(value)
        self._bubble_up(len(self.heap) - 1)
    
    def extract_max(self):
        """ìµœëŒ“ê°’ ì¶”ì¶œ"""
        if not self.heap:
            return None
        
        if len(self.heap) == 1:
            return self.heap.pop()
        
        max_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._bubble_down(0)
        
        return max_val
    
    def _bubble_up(self, index):
        """ìƒí–¥ í™ ì¡°ì •"""
        parent_idx = self.parent(index)
        
        if index > 0 and self.heap[index] > self.heap[parent_idx]:
            self.heap[index], self.heap[parent_idx] = self.heap[parent_idx], self.heap[index]
            self._bubble_up(parent_idx)
    
    def _bubble_down(self, index):
        """í•˜í–¥ í™ ì¡°ì •"""
        largest = index
        left = self.left_child(index)
        right = self.right_child(index)
        
        if left < len(self.heap) and self.heap[left] > self.heap[largest]:
            largest = left
        
        if right < len(self.heap) and self.heap[right] > self.heap[largest]:
            largest = right
        
        if largest != index:
            self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]
            self._bubble_down(largest)
```

## âš¡ íŠ¹ìˆ˜ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜

### ê³„ìˆ˜ ì •ë ¬ (Counting Sort)

```python
def counting_sort(arr, max_val):
    """ê³„ìˆ˜ ì •ë ¬ êµ¬í˜„
    
    ì •ìˆ˜ ë°°ì—´ì—ì„œ ê°’ì˜ ë²”ìœ„ê°€ ì œí•œì ì¼ ë•Œ ì‚¬ìš©
    
    Time Complexity: O(n + k), këŠ” ê°’ì˜ ë²”ìœ„
    Space Complexity: O(k)
    """
    count = [0] * (max_val + 1)
    
    # ê° ê°’ì˜ ê°œìˆ˜ ì„¸ê¸°
    for num in arr:
        count[num] += 1
    
    # ëˆ„ì  ê°œìˆ˜ ê³„ì‚°
    for i in range(1, len(count)):
        count[i] += count[i - 1]
    
    # ê²°ê³¼ ë°°ì—´ ìƒì„±
    result = [0] * len(arr)
    for num in reversed(arr):
        result[count[num] - 1] = num
        count[num] -= 1
    
    return result
```

### ê¸°ìˆ˜ ì •ë ¬ (Radix Sort)

```python
def radix_sort(arr):
    """ê¸°ìˆ˜ ì •ë ¬ êµ¬í˜„
    
    Time Complexity: O(d * (n + k))
    d: ìë¦¿ìˆ˜, k: ì§„ë²•(ë³´í†µ 10)
    """
    if not arr:
        return arr
    
    max_num = max(arr)
    exp = 1
    
    while max_num // exp > 0:
        counting_sort_for_radix(arr, exp)
        exp *= 10
    
    return arr

def counting_sort_for_radix(arr, exp):
    """ê¸°ìˆ˜ ì •ë ¬ì„ ìœ„í•œ ê³„ìˆ˜ ì •ë ¬"""
    n = len(arr)
    output = [0] * n
    count = [0] * 10
    
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1
    
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1
    
    for i in range(n):
        arr[i] = output[i]
```

## ğŸ—‚ï¸ í•´ì‹± (Hashing)

í•´ì‹±ì€ ì§ì ‘ì ì¸ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ ì•„ë‹ˆì§€ë§Œ, ë°ì´í„°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì €ì¥í•˜ê³  ê²€ìƒ‰í•˜ëŠ” ë° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤.

### í•´ì‹œ í…Œì´ë¸” êµ¬í˜„

```python
class HashTable:
    """í•´ì‹œ í…Œì´ë¸” êµ¬í˜„"""
    
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]  # ì²´ì´ë‹ ë°©ì‹
    
    def _hash_function(self, key):
        """í•´ì‹œ í•¨ìˆ˜ (Division Method)"""
        if isinstance(key, str):
            return sum(ord(c) for c in key) % self.size
        return key % self.size
    
    def insert(self, key, value):
        """í‚¤-ê°’ ìŒ ì‚½ì…"""
        hash_index = self._hash_function(key)
        bucket = self.table[hash_index]
        
        # ê¸°ì¡´ í‚¤ê°€ ìˆìœ¼ë©´ ê°’ ì—…ë°ì´íŠ¸
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        
        # ìƒˆë¡œìš´ í‚¤-ê°’ ìŒ ì¶”ê°€
        bucket.append((key, value))
    
    def get(self, key):
        """ê°’ ì¡°íšŒ"""
        hash_index = self._hash_function(key)
        bucket = self.table[hash_index]
        
        for k, v in bucket:
            if k == key:
                return v
        
        raise KeyError(f"Key '{key}' not found")
    
    def delete(self, key):