# 6. 정렬 알고리즘 (Sorting Algorithms) 🔢

![Python](https://img.shields.io/badge/Python-3.7+-blue.svg)
![License](https://img.shields.io/badge/License-MIT-green.svg)
![Algorithms](https://img.shields.io/badge/Algorithms-Sorting-orange.svg)

정렬 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 배열하는 알고리즘입니다. 컴퓨터 과학의 핵심 주제 중 하나로, 다양한 접근 방식과 성능 특성을 가집니다.

> 💡 **이 README를 복사하여 GitHub 레포지토리에 바로 사용하실 수 있습니다!**

## 📋 목차

- [6. 정렬 알고리즘 (Sorting Algorithms) 🔢](#6-정렬-알고리즘-sorting-algorithms-)
  - [📋 목차](#-목차)
  - [🎯 개요](#-개요)
    - [정렬의 중요성](#정렬의-중요성)
  - [📊 정렬 알고리즘 비교표](#-정렬-알고리즘-비교표)
  - [🐌 O(n²) 정렬 알고리즘](#-on-정렬-알고리즘)
    - [선택 정렬 (Selection Sort)](#선택-정렬-selection-sort)
      - [동작 원리](#동작-원리)
      - [구현](#구현)
    - [삽입 정렬 (Insertion Sort)](#삽입-정렬-insertion-sort)
      - [동작 원리](#동작-원리-1)
      - [구현](#구현-1)
    - [버블 정렬 (Bubble Sort)](#버블-정렬-bubble-sort)
      - [동작 원리](#동작-원리-2)
      - [구현](#구현-2)
  - [🚀 O(n log n) 정렬 알고리즘](#-on-log-n-정렬-알고리즘)
    - [퀸 정렬 (Quick Sort)](#퀸-정렬-quick-sort)
      - [동작 원리](#동작-원리-3)
      - [구현](#구현-3)
    - [병합 정렬 (Merge Sort)](#병합-정렬-merge-sort)
      - [동작 원리](#동작-원리-4)
      - [구현](#구현-4)
    - [힙 정렬 (Heap Sort)](#힙-정렬-heap-sort)
      - [동작 원리](#동작-원리-5)
      - [구현](#구현-5)
  - [⚡ 특수 정렬 알고리즘](#-특수-정렬-알고리즘)
    - [계수 정렬 (Counting Sort)](#계수-정렬-counting-sort)
    - [기수 정렬 (Radix Sort)](#기수-정렬-radix-sort)
  - [🗂️ 해싱 (Hashing)](#️-해싱-hashing)
    - [해시 테이블 구현](#해시-테이블-구현)

## 🎯 개요

정렬은 **데이터를 특정 기준에 따라 순서대로 배열하는 과정**입니다. 효율적인 정렬은 검색, 데이터베이스 최적화, 알고리즘 성능 향상의 핵심입니다.

### 정렬의 중요성

- **검색 효율성**: 정렬된 데이터는 이진 탐색 등으로 빠른 검색 가능
- **데이터 분석**: 최댓값, 최솟값, 중앙값 등을 쉽게 찾을 수 있음
- **알고리즘 전처리**: 많은 알고리즘이 정렬된 데이터를 입력으로 요구
- **사용자 경험**: 정렬된 데이터는 사용자가 이해하기 쉬움

## 📊 정렬 알고리즘 비교표

| 알고리즘 | 최선 | 평균 | 최악 | 공간복잡도 | 안정성 | 특징 |
|---------|------|------|------|-----------|--------|------|
| **선택 정렬** | O(n²) | O(n²) | O(n²) | O(1) | ❌ | 간단, 메모리 효율적 |
| **삽입 정렬** | O(n) | O(n²) | O(n²) | O(1) | ✅ | 작은 데이터셋에 효율적 |
| **버블 정렬** | O(n) | O(n²) | O(n²) | O(1) | ✅ | 교육용, 실용성 낮음 |
| **퀵 정렬** | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ | 빠름, 실용적 |
| **병합 정렬** | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ | 안정적 성능 |
| **힙 정렬** | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ | 메모리 효율적 |

> **안정성(Stability)**: 동일한 값을 가진 원소들의 상대적 순서가 정렬 후에도 유지되는 성질

## 🐌 O(n²) 정렬 알고리즘

### 선택 정렬 (Selection Sort)

매번 최솟값을 찾아서 앞쪽으로 이동시키는 방식입니다.

#### 동작 원리

```
초기 배열: [64, 25, 12, 22, 11]

1단계: [11, 25, 12, 22, 64]  (11이 최솟값)
2단계: [11, 12, 25, 22, 64]  (12가 최솟값)
3단계: [11, 12, 22, 25, 64]  (22가 최솟값)
4단계: [11, 12, 22, 25, 64]  (25가 최솟값)
```

#### 구현

```python
def selection_sort(arr):
    """선택 정렬 구현
    
    Args:
        arr: 정렬할 리스트
    
    Returns:
        정렬된 리스트
    
    Time Complexity: O(n²)
    Space Complexity: O(1)
    """
    n = len(arr)
    
    for i in range(n):
        # 최솟값의 인덱스 찾기
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # 최솟값을 현재 위치로 이동
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        
        # 중간 과정 출력 (디버깅용)
        print(f"단계 {i+1}: {arr}")
    
    return arr

# 사용 예제
if __name__ == "__main__":
    data = [64, 25, 12, 22, 11]
    print("초기 배열:", data)
    sorted_data = selection_sort(data.copy())
    print("정렬 완료:", sorted_data)
```

### 삽입 정렬 (Insertion Sort)

정렬된 부분에 새로운 원소를 적절한 위치에 삽입하는 방식입니다.

#### 동작 원리

```
초기 배열: [64, 25, 12, 22, 11]

1단계: [25, 64, 12, 22, 11]  (25를 정렬된 부분에 삽입)
2단계: [12, 25, 64, 22, 11]  (12를 정렬된 부분에 삽입)
3단계: [12, 22, 25, 64, 11]  (22를 정렬된 부분에 삽입)
4단계: [11, 12, 22, 25, 64]  (11을 정렬된 부분에 삽입)
```

#### 구현

```python
def insertion_sort(arr):
    """삽입 정렬 구현
    
    Args:
        arr: 정렬할 리스트
    
    Returns:
        정렬된 리스트
    
    Time Complexity: O(n²) - 최선의 경우 O(n)
    Space Complexity: O(1)
    """
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        # key보다 큰 원소들을 한 칸씩 뒤로 이동
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        # key를 적절한 위치에 삽입
        arr[j + 1] = key
        
        print(f"단계 {i}: {arr}")
    
    return arr

# 이진 삽입 정렬 (Binary Insertion Sort)
def binary_insertion_sort(arr):
    """이진 탐색을 이용한 삽입 정렬
    
    삽입 위치를 찾는 과정을 이진 탐색으로 최적화
    비교 횟수는 줄이지만 이동 횟수는 동일하여 전체 복잡도는 O(n²)
    """
    def binary_search(arr, val, start, end):
        if start == end:
            return start if arr[start] > val else start + 1
        
        if start > end:
            return start
        
        mid = (start + end) // 2
        
        if arr[mid] < val:
            return binary_search(arr, val, mid + 1, end)
        elif arr[mid] > val:
            return binary_search(arr, val, start, mid - 1)
        else:
            return mid
    
    for i in range(1, len(arr)):
        key = arr[i]
        j = binary_search(arr, key, 0, i - 1)
        
        # 원소들을 한 칸씩 뒤로 이동
        arr[j + 1:i + 1] = arr[j:i]
        arr[j] = key
    
    return arr
```

### 버블 정렬 (Bubble Sort)

인접한 원소들을 비교하여 큰 값을 뒤로 보내는 방식입니다.

#### 동작 원리

```
초기 배열: [64, 25, 12, 22, 11]

1패스: [25, 12, 22, 11, 64]  (64가 끝으로)
2패스: [12, 22, 11, 25, 64]  (25가 적절한 위치로)
3패스: [12, 11, 22, 25, 64]  (22가 적절한 위치로)
4패스: [11, 12, 22, 25, 64]  (12가 적절한 위치로)
```

#### 구현

```python
def bubble_sort(arr):
    """버블 정렬 구현
    
    Args:
        arr: 정렬할 리스트
    
    Returns:
        정렬된 리스트
    
    Time Complexity: O(n²) - 최선의 경우 O(n)
    Space Complexity: O(1)
    """
    n = len(arr)
    
    for i in range(n):
        swapped = False
        
        # 마지막 i개 원소는 이미 정렬됨
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        print(f"패스 {i+1}: {arr}")
        
        # 교환이 없었다면 정렬 완료
        if not swapped:
            break
    
    return arr

# 최적화된 버블 정렬
def optimized_bubble_sort(arr):
    """최적화된 버블 정렬
    
    - 조기 종료: 교환이 없으면 정렬 완료로 판단
    - 경계 최적화: 마지막 교환 위치를 기억하여 다음 패스의 범위 축소
    """
    n = len(arr)
    
    while n > 1:
        new_n = 0
        for i in range(1, n):
            if arr[i-1] > arr[i]:
                arr[i-1], arr[i] = arr[i], arr[i-1]
                new_n = i
        n = new_n
    
    return arr
```

## 🚀 O(n log n) 정렬 알고리즘

### 퀸 정렬 (Quick Sort)

피벗을 기준으로 분할 정복하는 방식입니다.

#### 동작 원리

```
초기 배열: [64, 25, 12, 22, 11]
피벗: 64

1. 분할: [25, 12, 22, 11] + [64] + []
2. 재귀적으로 왼쪽 부분 정렬: [11, 12, 22, 25]
3. 결합: [11, 12, 22, 25, 64]
```

#### 구현

```python
def quick_sort(arr, low=0, high=None):
    """퀵 정렬 구현
    
    Args:
        arr: 정렬할 리스트
        low: 정렬 시작 인덱스
        high: 정렬 끝 인덱스
    
    Returns:
        정렬된 리스트
    
    Time Complexity: 평균 O(n log n), 최악 O(n²)
    Space Complexity: O(log n)
    """
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        # 분할
        pivot_index = partition(arr, low, high)
        
        # 피벗 기준 왼쪽과 오른쪽 재귀 정렬
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)
    
    return arr

def partition(arr, low, high):
    """피벗을 기준으로 배열 분할
    
    Lomuto 분할 방식 사용
    """
    pivot = arr[high]  # 마지막 원소를 피벗으로 선택
    i = low - 1  # 작은 원소들의 마지막 인덱스
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    # 피벗을 적절한 위치에 배치
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# Hoare 분할 방식
def hoare_partition(arr, low, high):
    """Hoare 분할 방식
    
    양쪽 끝에서 시작하여 중앙으로 이동하며 분할
    일반적으로 Lomuto보다 약간 더 효율적
    """
    pivot = arr[low]
    i = low - 1
    j = high + 1
    
    while True:
        i += 1
        while arr[i] < pivot:
            i += 1
        
        j -= 1
        while arr[j] > pivot:
            j -= 1
        
        if i >= j:
            return j
        
        arr[i], arr[j] = arr[j], arr[i]

# 랜덤 피벗 퀵 정렬
import random

def randomized_quick_sort(arr, low=0, high=None):
    """랜덤 피벗 퀵 정렬
    
    피벗을 랜덤하게 선택하여 최악 케이스 확률을 줄임
    """
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        # 랜덤 피벗 선택
        random_index = random.randint(low, high)
        arr[random_index], arr[high] = arr[high], arr[random_index]
        
        pivot_index = partition(arr, low, high)
        randomized_quick_sort(arr, low, pivot_index - 1)
        randomized_quick_sort(arr, pivot_index + 1, high)
    
    return arr
```

### 병합 정렬 (Merge Sort)

분할 정복으로 정렬 후 병합하는 방식입니다.

#### 동작 원리

```
초기 배열: [64, 25, 12, 22, 11]

1. 분할: [64, 25] [12, 22, 11]
2. 재귀 분할: [64] [25] [12] [22, 11]
3. 재귀 분할: [64] [25] [12] [22] [11]
4. 병합: [25, 64] [12] [11, 22]
5. 병합: [25, 64] [11, 12, 22]
6. 병합: [11, 12, 22, 25, 64]
```

#### 구현

```python
def merge_sort(arr):
    """병합 정렬 구현
    
    Args:
        arr: 정렬할 리스트
    
    Returns:
        정렬된 리스트
    
    Time Complexity: O(n log n)
    Space Complexity: O(n)
    """
    if len(arr) <= 1:
        return arr
    
    # 분할
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # 병합
    return merge(left, right)

def merge(left, right):
    """두 정렬된 배열을 병합
    
    Args:
        left: 왼쪽 정렬된 배열
        right: 오른쪽 정렬된 배열
    
    Returns:
        병합된 정렬 배열
    """
    result = []
    i = j = 0
    
    # 두 배열을 비교하며 병합
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # 남은 원소들 추가
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# In-place 병합 정렬 (메모리 최적화)
def in_place_merge_sort(arr, left=0, right=None):
    """In-place 병합 정렬
    
    메모리 사용량을 줄인 버전이지만 구현이 복잡함
    """
    if right is None:
        right = len(arr) - 1
    
    if left < right:
        mid = (left + right) // 2
        in_place_merge_sort(arr, left, mid)
        in_place_merge_sort(arr, mid + 1, right)
        in_place_merge(arr, left, mid, right)
    
    return arr

def in_place_merge(arr, left, mid, right):
    """In-place 병합 함수"""
    # 구현이 복잡하여 일반적으로는 추가 메모리를 사용하는 방식을 선호
    start2 = mid + 1
    
    if arr[mid] <= arr[start2]:
        return
    
    while left <= mid and start2 <= right:
        if arr[left] <= arr[start2]:
            left += 1
        else:
            value = arr[start2]
            index = start2
            
            while index != left:
                arr[index] = arr[index - 1]
                index -= 1
            
            arr[left] = value
            left += 1
            mid += 1
            start2 += 1
```

### 힙 정렬 (Heap Sort)

힙 자료구조를 이용한 정렬입니다.

#### 동작 원리

```
초기 배열: [64, 25, 12, 22, 11]

1. 최대 힙 구성: [64, 25, 12, 22, 11]
2. 루트(최댓값)를 끝으로: [11, 25, 12, 22, 64]
3. 힙 재구성: [25, 22, 12, 11, 64]
4. 반복: [11, 12, 22, 25, 64]
```

#### 구현

```python
def heap_sort(arr):
    """힙 정렬 구현
    
    Args:
        arr: 정렬할 리스트
    
    Returns:
        정렬된 리스트
    
    Time Complexity: O(n log n)
    Space Complexity: O(1)
    """
    n = len(arr)
    
    # 최대 힙 구성 (bottom-up)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # 힙에서 원소를 하나씩 추출
    for i in range(n - 1, 0, -1):
        # 루트(최댓값)를 현재 마지막과 교환
        arr[0], arr[i] = arr[i], arr[0]
        
        # 감소된 힙에서 루트를 힙 속성에 맞게 조정
        heapify(arr, i, 0)
    
    return arr

def heapify(arr, heap_size, root_index):
    """힙 속성 유지 함수
    
    Args:
        arr: 배열
        heap_size: 힙 크기
        root_index: 루트 인덱스
    """
    largest = root_index  # 가장 큰 값을 루트로 초기화
    left = 2 * root_index + 1  # 왼쪽 자식
    right = 2 * root_index + 2  # 오른쪽 자식
    
    # 왼쪽 자식이 루트보다 크면
    if left < heap_size and arr[left] > arr[largest]:
        largest = left
    
    # 오른쪽 자식이 현재 가장 큰 값보다 크면
    if right < heap_size and arr[right] > arr[largest]:
        largest = right
    
    # 가장 큰 값이 루트가 아니면
    if largest != root_index:
        arr[root_index], arr[largest] = arr[largest], arr[root_index]
        
        # 재귀적으로 힙 속성 유지
        heapify(arr, heap_size, largest)

# 힙 클래스를 이용한 구현
class MaxHeap:
    """최대 힙 클래스"""
    
    def __init__(self):
        self.heap = []
    
    def parent(self, i):
        return (i - 1) // 2
    
    def left_child(self, i):
        return 2 * i + 1
    
    def right_child(self, i):
        return 2 * i + 2
    
    def insert(self, value):
        """힙에 값 삽입"""
        self.heap.append(value)
        self._bubble_up(len(self.heap) - 1)
    
    def extract_max(self):
        """최댓값 추출"""
        if not self.heap:
            return None
        
        if len(self.heap) == 1:
            return self.heap.pop()
        
        max_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._bubble_down(0)
        
        return max_val
    
    def _bubble_up(self, index):
        """상향 힙 조정"""
        parent_idx = self.parent(index)
        
        if index > 0 and self.heap[index] > self.heap[parent_idx]:
            self.heap[index], self.heap[parent_idx] = self.heap[parent_idx], self.heap[index]
            self._bubble_up(parent_idx)
    
    def _bubble_down(self, index):
        """하향 힙 조정"""
        largest = index
        left = self.left_child(index)
        right = self.right_child(index)
        
        if left < len(self.heap) and self.heap[left] > self.heap[largest]:
            largest = left
        
        if right < len(self.heap) and self.heap[right] > self.heap[largest]:
            largest = right
        
        if largest != index:
            self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]
            self._bubble_down(largest)
```

## ⚡ 특수 정렬 알고리즘

### 계수 정렬 (Counting Sort)

```python
def counting_sort(arr, max_val):
    """계수 정렬 구현
    
    정수 배열에서 값의 범위가 제한적일 때 사용
    
    Time Complexity: O(n + k), k는 값의 범위
    Space Complexity: O(k)
    """
    count = [0] * (max_val + 1)
    
    # 각 값의 개수 세기
    for num in arr:
        count[num] += 1
    
    # 누적 개수 계산
    for i in range(1, len(count)):
        count[i] += count[i - 1]
    
    # 결과 배열 생성
    result = [0] * len(arr)
    for num in reversed(arr):
        result[count[num] - 1] = num
        count[num] -= 1
    
    return result
```

### 기수 정렬 (Radix Sort)

```python
def radix_sort(arr):
    """기수 정렬 구현
    
    Time Complexity: O(d * (n + k))
    d: 자릿수, k: 진법(보통 10)
    """
    if not arr:
        return arr
    
    max_num = max(arr)
    exp = 1
    
    while max_num // exp > 0:
        counting_sort_for_radix(arr, exp)
        exp *= 10
    
    return arr

def counting_sort_for_radix(arr, exp):
    """기수 정렬을 위한 계수 정렬"""
    n = len(arr)
    output = [0] * n
    count = [0] * 10
    
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1
    
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1
    
    for i in range(n):
        arr[i] = output[i]
```

## 🗂️ 해싱 (Hashing)

해싱은 직접적인 정렬 알고리즘은 아니지만, 데이터를 효율적으로 저장하고 검색하는 데 중요한 역할을 합니다.

### 해시 테이블 구현

```python
class HashTable:
    """해시 테이블 구현"""
    
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]  # 체이닝 방식
    
    def _hash_function(self, key):
        """해시 함수 (Division Method)"""
        if isinstance(key, str):
            return sum(ord(c) for c in key) % self.size
        return key % self.size
    
    def insert(self, key, value):
        """키-값 쌍 삽입"""
        hash_index = self._hash_function(key)
        bucket = self.table[hash_index]
        
        # 기존 키가 있으면 값 업데이트
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        
        # 새로운 키-값 쌍 추가
        bucket.append((key, value))
    
    def get(self, key):
        """값 조회"""
        hash_index = self._hash_function(key)
        bucket = self.table[hash_index]
        
        for k, v in bucket:
            if k == key:
                return v
        
        raise KeyError(f"Key '{key}' not found")
    
    def delete(self, key):