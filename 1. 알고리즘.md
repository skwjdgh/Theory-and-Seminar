## 1. 데이터 구조 (Data Structure)

### 1.1 기본 개념

데이터 구조는 데이터를 효율적으로 저장하고 조직화하는 방법입니다.

**분류:**
- **선형 구조**: 데이터가 순차적으로 나열된 구조
  - 배열 (Array)
  - 리스트 (List)
  - 스택 (Stack)
  - 큐 (Queue)

- **비선형 구조**: 데이터가 계층적 또는 네트워크 형태로 구성된 구조
  - 트리 (Tree)
  - 그래프 (Graph)
  - 해시 테이블 (Hash Table)

### 1.1.2 선택 기준

- **시간 복잡도**: 연산 수행 시간
- **공간 복잡도**: 메모리 사용량
- **용도**: 어떤 연산을 주로 수행하는가?
- **확장성**: 데이터 크기 변화에 대한 대응

---

## 1.2 알고리즘 (Algorithm)

### 1.2.1 정의

알고리즘은 문제를 해결하기 위한 단계적 절차입니다.

### 1.2.2 특성

1. **입력**: 0개 이상의 입력이 있어야 함
2. **출력**: 1개 이상의 출력이 있어야 함
3. **명확성**: 각 단계가 명확해야 함
4. **유한성**: 유한한 단계 후에 종료되어야 함
5. **효율성**: 실행 가능해야 함

### 1.2.3 의사코드 (Pseudocode) 예시

\```
Algorithm FindMax(A, n)
Input: 배열 A[1...n], 크기 n
Output: 배열의 최대값

Begin
  max ← A[1]
  for i ← 2 to n do
    if A[i] > max then
      max ← A[i]
  return max
End
\```

## 1.3 추상 데이터 타입 (ADT)

### 1.3.1 개념

ADT는 데이터와 연산을 하나로 묶어 추상화한 것으로, **무엇을** 할 수 있는지에 초점을 맞춥니다.

### 1.3.2 정보 은닉

- 내부 구현을 숨기고 인터페이스만 제공
- 구현 방법을 바꾸어도 사용자 코드에 영향 없음

### 1.3.3 Python ADT 예시

\```python
class AbstractDataType:
    def __init__(self):
        self._data = []  # 내부 구현 (private)
    
    def insert(self, item):
        """추상 메서드 - 하위 클래스에서 구현"""
        raise NotImplementedError
    
    def size(self):
        """공통 메서드"""
        return len(self._data)
\```
## 1.4 시간 복잡도 분석

### 1.4.1 Big O 표기법

시간 복잡도를 나타내는 점근적 표기법입니다.

| 표기법 | 이름 | 설명 | 예시 |
|--------|------|------|------|
| O(1) | 상수 시간 | 입력 크기와 무관 | 배열 인덱스 접근 |
| O(log n) | 로그 시간 | 입력이 절반씩 줄어듦 | 이진 탐색 |
| O(n) | 선형 시간 | 입력 크기에 비례 | 선형 탐색 |
| O(n log n) | 선형 로그 시간 | 효율적인 정렬 | 병합 정렬 |
| O(n²) | 이차 시간 | 중첩 반복문 | 버블 정렬 |
| O(2ⁿ) | 지수 시간 | 매우 비효율적 | 피보나치 (순진한 재귀) |

### 1.4.2 복잡도 분석 예시

\```python
# O(n) - 선형 시간
def linear_search(arr, target):
    for i in range(len(arr)):  # n번 반복
        if arr[i] == target:
            return i
    return -1

# O(n²) - 이차 시간
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):         # n번 반복
        for j in range(n-1):   # n번 반복
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
\```

### 1.4.3 최선/평균/최악의 경우

- **최선의 경우**: 알고리즘이 가장 빠르게 실행되는 경우
- **평균의 경우**: 일반적인 입력에 대한 평균 수행 시간
- **최악의 경우**: 알고리즘이 가장 오래 걸리는 경우

---