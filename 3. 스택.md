## 3. 스택 (Stack)

### 3.1 LIFO 원리

스택은 **Last-In First-Out** 구조로, 가장 마지막에 들어간 요소가 가장 먼저 나옵니다.

### 3.2 스택 ADT

\```python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """스택 상단에 요소 추가"""
        self.items.append(item)
    
    def pop(self):
        """스택 상단에서 요소 제거 및 반환"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.items.pop()
    
    def peek(self):
        """스택 상단 요소 확인 (제거하지 않음)"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.items[-1]
    
    def is_empty(self):
        """스택이 비어있는지 확인"""
        return len(self.items) == 0
    
    def size(self):
        """스택 크기 반환"""
        return len(self.items)
    
    def clear(self):
        """스택 초기화"""
        self.items = []
\```

### 3.3 스택의 응용

#### 3.3.1 괄호 매칭 검사

\```python
def check_brackets(expression):
    stack = Stack()
    brackets = {'(': ')', '[': ']', '{': '}'}
    
    for char in expression:
        if char in brackets:  # 여는 괄호
            stack.push(char)
        elif char in brackets.values():  # 닫는 괄호
            if stack.is_empty():
                return False
            if brackets[stack.pop()] != char:
                return False
    
    return stack.is_empty()

# 사용 예시
print(check_brackets("((()))"))  # True
print(check_brackets("([)]"))    # False
\```

#### 3.3.2 후위 표기법 계산

\```python
def evaluate_postfix(expression):
    stack = Stack()
    operators = {'+', '-', '*', '/'}
    
    for token in expression.split():
        if token in operators:
            if stack.size() < 2:
                raise ValueError("Invalid expression")
            
            b = stack.pop()
            a = stack.pop()
            
            if token == '+':
                result = a + b
            elif token == '-':
                result = a - b
            elif token == '*':
                result = a * b
            elif token == '/':
                result = a / b
            
            stack.push(result)
        else:
            stack.push(float(token))
    
    if stack.size() != 1:
        raise ValueError("Invalid expression")
    
    return stack.pop()

# 사용 예시: "3 4 + 2 *" = (3 + 4) * 2 = 14
print(evaluate_postfix("3 4 + 2 *"))  # 14.0
\```

#### 3.3.3 미로 찾기 (백트래킹)

\```python
def solve_maze(maze, start, end):
    stack = Stack()
    stack.push(start)
    visited = set()
    path = {}
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 상하좌우
    
    while not stack.is_empty():
        current = stack.pop()
        
        if current == end:
            # 경로 재구성
            path_list = []
            while current in path:
                path_list.append(current)
                current = path[current]
            path_list.append(start)
            return path_list[::-1]
        
        if current in visited:
            continue
        
        visited.add(current)
        x, y = current
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if (0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and
                maze[nx][ny] == 0 and (nx, ny) not in visited):
                stack.push((nx, ny))
                path[(nx, ny)] = current
    
    return None  # 경로 없음
\```

---