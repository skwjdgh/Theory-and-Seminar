# 5. 연결 리스트 (Linked List) 📚

![Python](https://img.shields.io/badge/Python-3.7+-blue.svg)
![License](https://img.shields.io/badge/License-MIT-green.svg)

연결 리스트는 동적 메모리 할당을 이용한 선형 자료구조로, 데이터를 순서대로 연결하여 저장하는 방식입니다.

> 💡 **이 README를 복사하여 GitHub 레포지토리에 바로 사용하실 수 있습니다!**

## 📋 목차

- [개요](#개요)
- [연결 리스트 vs 배열](#연결-리스트-vs-배열)
- [연결 리스트의 구조](#연결-리스트의-구조)
- [연결 리스트의 유형](#연결-리스트의-유형)
- [기본 연산](#기본-연산)
- [Python 구현](#python-구현)
- [시간 복잡도](#시간-복잡도)
- [실제 활용 사례](#실제-활용-사례)
- [연습 문제](#연습-문제)

## 🎯 개요

연결 리스트는 **노드(Node)**라는 단위로 데이터를 저장하며, 각 노드는 다음과 같이 구성됩니다:

```
┌─────────┬─────────┐
│  Data   │  Link   │
├─────────┼─────────┤
│   10    │    ●────┼──→ 다음 노드
└─────────┴─────────┘
```

### 주요 특징

- **동적 크기**: 실행 시간에 크기가 결정됨
- **메모리 효율성**: 필요한 만큼만 메모리 사용
- **순차 접근**: 첫 번째 노드부터 순서대로 접근

## ⚖️ 연결 리스트 vs 배열

| 특성 | 배열 (Array) | 연결 리스트 (Linked List) |
|------|-------------|-------------------------|
| **메모리 할당** | 정적 (컴파일 시) | 동적 (실행 시) |
| **크기** | 고정 | 가변 |
| **메모리 사용** | 연속적 | 비연속적 |
| **접근 방식** | 인덱스 (직접) | 포인터 (순차) |
| **삽입/삭제** | O(n) - 요소 이동 필요 | O(1) - 포인터만 변경 |
| **메모리 오버헤드** | 없음 | 포인터 저장 공간 필요 |

### 배열의 한계점

```python
# 배열의 문제점 예시
arr = [1, 2, 3, 4, 5]  # 크기 고정

# 중간에 삽입 시 모든 요소를 이동해야 함
# [1, 2, 3, 4, 5] → [1, 2, 99, 3, 4, 5]
#          ↑ 여기에 99 삽입하려면 3,4,5를 모두 뒤로 이동
```

### 연결 리스트의 장점

```python
# 연결 리스트의 삽입
# [1]→[2]→[3]→[4]→[5]
#      ↓ 99 삽입
# [1]→[2]→[99]→[3]→[4]→[5]
# 포인터만 변경하면 됨!
```

## 🏗️ 연결 리스트의 구조

### 기본 구조

```
Header Pointer
     ↓
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ 10 │  ●─┼───→│ 20 │  ●─┼───→│ 30 │  ●─┼───→│ 40 │ NULL│
└─────────┘    └─────────┘    └─────────┘    └─────────┘
   Node 1         Node 2         Node 3         Node 4
```

### 노드의 구성요소

1. **Data Field**: 실제 데이터를 저장
2. **Link Field**: 다음 노드의 주소를 저장
3. **Header Pointer**: 첫 번째 노드를 가리키는 포인터

## 🔄 연결 리스트의 유형

### 1. 단일 연결 리스트 (Singly Linked List)

```
[A]→[B]→[C]→[D]→NULL
```

- 각 노드가 다음 노드만 가리킴
- 한 방향으로만 순회 가능

### 2. 이중 연결 리스트 (Doubly Linked List)

```
NULL←[A]⇄[B]⇄[C]⇄[D]→NULL
```

- 각 노드가 이전/다음 노드 모두 가리킴
- 양방향 순회 가능

### 3. 원형 연결 리스트 (Circular Linked List)

```
[A]→[B]→[C]→[D]
 ↑              ↓
 └──────────────┘
```

- 마지막 노드가 첫 번째 노드를 가리킴
- 순환 구조

## 🛠️ 기본 연산

### ADT (Abstract Data Type) 정의

```python
class LinkedListADT:
    def isEmpty(self) -> bool:
        """리스트가 비어있는지 확인"""
        pass
    
    def push(self, data) -> None:
        """노드 삽입"""
        pass
    
    def pop(self) -> any:
        """노드 삭제 및 반환"""
        pass
    
    def peek(self) -> any:
        """첫 번째 노드 확인 (삭제하지 않음)"""
        pass
    
    def size(self) -> int:
        """리스트 크기 반환"""
        pass
    
    def clear(self) -> None:
        """리스트 초기화"""
        pass
```

## 💻 Python 구현

### 노드 클래스

```python
class Node:
    """연결 리스트의 노드를 나타내는 클래스"""
    
    def __init__(self, data=None):
        self.data = data  # 데이터 저장
        self.next = None  # 다음 노드를 가리키는 포인터
    
    def __str__(self):
        return str(self.data)
```

### 연결 리스트 클래스

```python
class LinkedList:
    """단일 연결 리스트 구현"""
    
    def __init__(self):
        self.head = None  # 헤드 포인터
        self._size = 0    # 리스트 크기
    
    def isEmpty(self) -> bool:
        """리스트가 비어있는지 확인
        
        Returns:
            bool: 비어있으면 True, 아니면 False
        
        Time Complexity: O(1)
        """
        return self.head is None
    
    def size(self) -> int:
        """리스트의 크기 반환
        
        Returns:
            int: 노드의 개수
        
        Time Complexity: O(1)
        """
        return self._size
    
    def push_front(self, data) -> None:
        """리스트 앞쪽에 노드 삽입
        
        Args:
            data: 삽입할 데이터
        
        Time Complexity: O(1)
        """
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self._size += 1
    
    def push_back(self, data) -> None:
        """리스트 뒤쪽에 노드 삽입
        
        Args:
            data: 삽입할 데이터
        
        Time Complexity: O(n)
        """
        new_node = Node(data)
        
        if self.isEmpty():
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        
        self._size += 1
    
    def insert_at(self, index: int, data) -> None:
        """특정 위치에 노드 삽입
        
        Args:
            index: 삽입할 위치 (0부터 시작)
            data: 삽입할 데이터
        
        Raises:
            IndexError: 인덱스가 범위를 벗어날 때
        
        Time Complexity: O(n)
        """
        if index < 0 or index > self._size:
            raise IndexError("Index out of range")
        
        if index == 0:
            self.push_front(data)
            return
        
        new_node = Node(data)
        current = self.head
        
        for _ in range(index - 1):
            current = current.next
        
        new_node.next = current.next
        current.next = new_node
        self._size += 1
    
    def pop_front(self):
        """첫 번째 노드 삭제 및 반환
        
        Returns:
            삭제된 노드의 데이터
        
        Raises:
            RuntimeError: 빈 리스트에서 삭제를 시도할 때
        
        Time Complexity: O(1)
        """
        if self.isEmpty():
            raise RuntimeError("Cannot pop from empty list")
        
        data = self.head.data
        self.head = self.head.next
        self._size -= 1
        return data
    
    def pop_back(self):
        """마지막 노드 삭제 및 반환
        
        Returns:
            삭제된 노드의 데이터
        
        Raises:
            RuntimeError: 빈 리스트에서 삭제를 시도할 때
        
        Time Complexity: O(n)
        """
        if self.isEmpty():
            raise RuntimeError("Cannot pop from empty list")
        
        if self._size == 1:
            return self.pop_front()
        
        current = self.head
        while current.next.next:
            current = current.next
        
        data = current.next.data
        current.next = None
        self._size -= 1
        return data
    
    def remove_at(self, index: int):
        """특정 위치의 노드 삭제
        
        Args:
            index: 삭제할 위치 (0부터 시작)
        
        Returns:
            삭제된 노드의 데이터
        
        Raises:
            IndexError: 인덱스가 범위를 벗어날 때
        
        Time Complexity: O(n)
        """
        if index < 0 or index >= self._size:
            raise IndexError("Index out of range")
        
        if index == 0:
            return self.pop_front()
        
        current = self.head
        for _ in range(index - 1):
            current = current.next
        
        data = current.next.data
        current.next = current.next.next
        self._size -= 1
        return data
    
    def find(self, data) -> int:
        """특정 데이터의 인덱스 반환
        
        Args:
            data: 찾을 데이터
        
        Returns:
            int: 데이터의 인덱스, 없으면 -1
        
        Time Complexity: O(n)
        """
        current = self.head
        index = 0
        
        while current:
            if current.data == data:
                return index
            current = current.next
            index += 1
        
        return -1
    
    def get(self, index: int):
        """특정 위치의 데이터 반환
        
        Args:
            index: 조회할 위치 (0부터 시작)
        
        Returns:
            해당 위치의 데이터
        
        Raises:
            IndexError: 인덱스가 범위를 벗어날 때
        
        Time Complexity: O(n)
        """
        if index < 0 or index >= self._size:
            raise IndexError("Index out of range")
        
        current = self.head
        for _ in range(index):
            current = current.next
        
        return current.data
    
    def clear(self) -> None:
        """리스트 초기화
        
        Time Complexity: O(1)
        """
        self.head = None
        self._size = 0
    
    def to_list(self) -> list:
        """연결 리스트를 Python 리스트로 변환
        
        Returns:
            list: 연결 리스트의 모든 데이터를 담은 리스트
        
        Time Complexity: O(n)
        """
        result = []
        current = self.head
        
        while current:
            result.append(current.data)
            current = current.next
        
        return result
    
    def __str__(self) -> str:
        """연결 리스트의 문자열 표현
        
        Returns:
            str: 리스트의 모든 요소를 화살표로 연결한 문자열
        """
        if self.isEmpty():
            return "Empty List"
        
        elements = []
        current = self.head
        
        while current:
            elements.append(str(current.data))
            current = current.next
        
        return " → ".join(elements) + " → NULL"
    
    def __len__(self) -> int:
        """len() 함수 지원"""
        return self._size
    
    def __iter__(self):
        """반복자 지원"""
        current = self.head
        while current:
            yield current.data
            current = current.next


# 사용 예제
if __name__ == "__main__":
    # 연결 리스트 생성
    linked_list = LinkedList()
    
    # 데이터 삽입
    linked_list.push_front(10)
    linked_list.push_front(20)
    linked_list.push_back(30)
    linked_list.push_back(40)
    
    print("연결 리스트:", linked_list)  # 20 → 10 → 30 → 40 → NULL
    print("크기:", len(linked_list))    # 4
    
    # 특정 위치에 삽입
    linked_list.insert_at(2, 25)
    print("삽입 후:", linked_list)      # 20 → 10 → 25 → 30 → 40 → NULL
    
    # 데이터 삭제
    print("삭제된 데이터:", linked_list.pop_front())  # 20
    print("삭제 후:", linked_list)      # 10 → 25 → 30 → 40 → NULL
    
    # 데이터 검색
    print("25의 인덱스:", linked_list.find(25))  # 1
    
    # 반복자 사용
    print("모든 요소:", [data for data in linked_list])
```

## ⏱️ 시간 복잡도

| 연산 | 시간 복잡도 | 설명 |
|------|------------|-----|
| **삽입 (앞쪽)** | O(1) | 헤드 포인터만 변경 |
| **삽입 (뒤쪽)** | O(n) | 마지막 노드까지 순회 필요 |
| **삽입 (중간)** | O(n) | 해당 위치까지 순회 필요 |
| **삭제 (앞쪽)** | O(1) | 헤드 포인터만 변경 |
| **삭제 (뒤쪽)** | O(n) | 마지막 노드까지 순회 필요 |
| **삭제 (중간)** | O(n) | 해당 위치까지 순회 필요 |
| **검색** | O(n) | 순차 탐색 |
| **접근** | O(n) | 순차 접근만 가능 |

## 🌟 실제 활용 사례

### 1. 웹 브라우저 방문 기록

```python
class BrowserHistory:
    def __init__(self):
        self.history = LinkedList()
        self.current_page = 0
    
    def visit(self, url):
        self.history.push_back(url)
        self.current_page = self.history.size() - 1
    
    def back(self):
        if self.current_page > 0:
            self.current_page -= 1
            return self.history.get(self.current_page)
        return None
    
    def forward(self):
        if self.current_page < self.history.size() - 1:
            self.current_page += 1
            return self.history.get(self.current_page)
        return None
```

### 2. 음악 플레이어 재생목록

```python
class Playlist:
    def __init__(self):
        self.songs = LinkedList()
        self.current = 0
    
    def add_song(self, song):
        self.songs.push_back(song)
    
    def next_song(self):
        if self.current < self.songs.size() - 1:
            self.current += 1
        else:
            self.current = 0  # 처음으로 돌아가기
        return self.songs.get(self.current)
    
    def previous_song(self):
        if self.current > 0:
            self.current -= 1
        else:
            self.current = self.songs.size() - 1  # 마지막으로
        return self.songs.get(self.current)
```

### 3. 실행 취소 (Undo) 기능

```python
class UndoRedoManager:
    def __init__(self):
        self.actions = LinkedList()
        self.current_position = -1
    
    def execute_action(self, action):
        # 현재 위치 이후의 모든 액션 삭제
        while self.actions.size() > self.current_position + 1:
            self.actions.pop_back()
        
        self.actions.push_back(action)
        self.current_position += 1
        action.execute()
    
    def undo(self):
        if self.current_position >= 0:
            action = self.actions.get(self.current_position)
            action.undo()
            self.current_position -= 1
    
    def redo(self):
        if self.current_position < self.actions.size() - 1:
            self.current_position += 1
            action = self.actions.get(self.current_position)
            action.execute()
```

## 📝 연습 문제

### 초급

1. **연결 리스트 뒤집기**: 주어진 연결 리스트의 순서를 뒤집는 함수를 작성하세요.

```python
def reverse_linked_list(linked_list):
    # 여기에 코드를 작성하세요
    pass
```

2. **중복 제거**: 정렬된 연결 리스트에서 중복된 노드를 제거하는 함수를 작성하세요.

### 중급

3. **두 연결 리스트 합병**: 정렬된 두 연결 리스트를 하나의 정렬된 연결 리스트로 합병하세요.

4. **중간 노드 찾기**: 연결 리스트의 중간 노드를 찾는 함수를 작성하세요. (Two Pointer 기법 사용)

### 고급

5. **사이클 감지**: 연결 리스트에 사이클이 있는지 감지하는 함수를 작성하세요. (Floyd's Algorithm 사용)

6. **LRU 캐시**: 연결 리스트를 이용하여 LRU (Least Recently Used) 캐시를 구현하세요.

## 🔗 관련 자료구조

연결 리스트를 이해했다면 다음 자료구조들도 학습해보세요:

- **스택 (Stack)**: 연결 리스트로 구현 가능
- **큐 (Queue)**: 연결 리스트로 구현 가능
- **트리 (Tree)**: 연결 리스트의 확장 개념
- **그래프 (Graph)**: 인접 리스트로 표현 시 연결 리스트 사용
